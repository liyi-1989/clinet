{
    "collab_server" : "",
    "contents" : "library(MASS) # use mvnorm to generate multivariate normal\nlibrary(Matrix) # use \"dgCMatrix\" matrix class, so that to make plot of a matrix like hand written order\nlibrary(moments) # calculate higher order moments, skewness, kurtosis. not useful\nlibrary(pROC) # make ROC curve, not very useful currently\n\n# Generate V in the factor model\ngenV=function(p=100,r=0.5,s=0.2,sp,tele=F){\n  # p: number of features, assume equal number of latent factors. So V is p by p\n  # r: neighbour kernel bump\n  # s: tele connection bump scale\n  # sp positions of teleconnection, like c(5,90)\n  # tele: teleconnection signal. 1: s*(r,1,r) -1: s*(-r,1,-r)\n  if(missing(sp)){\n    sp=c(0.05*p,0.9*p)\n  }\n  V=matrix(0,p,p)\n  for(i in 1:p){\n    for(j in 1:p){\n      if((i==j) | (i-j)==2){\n        V[i,j]=r\n      }else if(i-j==1){\n        V[i,j]=1\n      }\n    }\n  }\n  if(tele==-1){\n    V[sp[2]:(sp[2]+2),sp[1]]=c(-r,1,-r)*s\n  }else if(tele==1){\n    V[sp[2]:(sp[2]+2),sp[1]]=c(r,1,r)*s\n  }\n  return(V)\n}\n\n# print a matrix with heatmap, in a hand written order, left->right, up->down (no need to rotate)\nprintM=function(M){\n  image(as(M, \"dgCMatrix\"),main=deparse(substitute(M)))\n}\n\n# plot the density of a sequence and its normal approx with same mean & sd\nplotDen=function(res){\n  plot(density(res),col=\"blue\",main=paste(\"Density of\",deparse(substitute(res))))\n  x=seq(min(res),max(res),length=100)\n  y=dnorm(x,mean=mean(res), sd=sd(res))\n  lines(x,y, type=\"l\", lwd=1,col=\"red\")\n  abline(v=mean(res),lty=2,col=\"orange\")\n  text(mean(res)+2*sd(res),range(density(res)$y)[2]/2,paste(\"mean:\",round(mean(res),4)),col=\"green\")\n  # fit Gumbel distribution\n  #y2=dGumbel(x, mu = mean(res)-0.5772*sd(res)*sqrt(6)/pi, sigma = sd(res)*sqrt(6)/pi, log = FALSE) \n  #lines(x,y2, type=\"l\", lwd=1,col=\"pink\")\n}\n\n# universal threshoulding\nregT=function(M,tres){\n  return(M*(M>tres))\n}\n\n# adaptive threshoulding \"Shat\" according to \"Snorm\"\n# (times const*sqrt(log(p)/n))\nregAT=function(Shat,Snorm,n,const=2){\n  p=dim(Shat)[1]\n  Shat=Shat*(Shat>const*(Snorm*sqrt(log(p)/n)))\n}\n\n# Calculate \"different norms\" of the h-nearest-neighbour small block of a matrix M\nMnormM=function(M,h=2,type=1,RM=F){\n  # h is the bandwidth\n  p=dim(M)[1]\n  normM=M\n  \n  # for(i in h:(p-h+1)){\n  #   for(j in h:(p-h+1)){\n  for(i in 1:(p)){\n    for(j in 1:(p)){    \n      il=max(i-h+1,1)\n      iu=min(i+h-1,p)\n      jl=max(j-h+1,1)\n      ju=min(j+h-1,p)\n      n0=(iu-il)*(ju-jl)\n      M0=M[il:iu,jl:ju]\n      if(RM){\n        M0=M0-mean(M0) ########\n      }\n      \n      if(type==1){\n        normM[i,j]=base::norm(M0,\"2\") \n      }else if(type==2){\n        normM[i,j]=base::norm(M0,\"F\")\n      }else if(type==3){\n        normM[i,j]=mean(M0)\n      }else if(type==4){\n        normM[i,j]=mean(abs(M0))\n      }else if(type==5){\n        normM[i,j]=log((prod(abs(M0)))^{1/n0})\n      }else if(type==6){\n        normM[i,j]=sort(M0,decreasing = TRUE)[2]\n      }else if(type==7){\n        m0=c(M0[2,2],M0[2,1],M0[2,3],M0[1,2],M0[3,2])\n        normM[i,j]=mean(m0)\n      }else if(type==8){\n        m0=c(M0[2,2],M0[2,1],M0[2,3],M0[1,2],M0[3,2])\n        normM[i,j]=abs(prod(m0))\n      }else if(type==9){\n        normM[i,j]=exp(-abs(mean(M0)))\n      }else if(type==10){\n        normM[i,j]=sd(c(M0))\n      }else if(type==11){\n        normM[i,j]=skewness(c(M0))\n      }else if(type==12){\n        normM[i,j]=kurtosis(c(M0))\n      }\n      \n    }\n  }\n  \n  return(normM)\n}\n\n# variance of a covariance elements (used in Tony Cai's Adaptive threshouding) \nMnormMvar=function(X){\n  n=dim(X)[1]\n  Sigma_hat=cov(X)\n  X1=apply(X,2,function(x){return (x-mean(x))}) # remove column mean version\n  Sigma_var=((t(X1^2)%*%(X1^2)))/n-2*Sigma_hat*(t(X1)%*%X1)/n+(Sigma_hat)^2\n  return(Sigma_var)\n  # n=dim(X)[1]; p=dim(X)[2]\n  # Xbar=as.matrix(apply(X,2,mean))\n  # S1=matrix(0,p,p)\n  # for(i in 1:p){\n  #   for(j in 1:p){\n  #     for(k in 1:n){\n  #       S1[i,j]=S1[i,j]+((X[k,i]-Xbar[i,1])*(X[k,j]-Xbar[j,1])-Sigma_hat[i,j])^2\n  #     }\n  #     \n  #   }\n  # }\n  # S1=S1/n\n  # return(list(Sigma_var=Sigma_var,S1=S1))\n}\n\n# main simulation function\n# See after \"block norm\", if the \"teleconnection signal\" could be stand out from the \"random noise\" (zeros). \nmaxnoise=function(p=p,type=0, n=2000, N=100, r,s,tele, sigma,RM=F){\n  # S: ground truth\n  # type: Estimator of S. 0 is sample covariance\n  # n: sample size to generate multivariate normal to get Shat (or other estimator)\n  # N: repeat time\n  # Goal: find sampling distribution for \n  # (1) random error for zeros in S; \n  # (2) (max) off-diagonal signal\n  #p=dim(S)[1]\n  Ip=diag(rep(1,p))\n  #r=0.95; s=0.5; tele=T\n  \n  resZ=resOffDiag=res691=rep(0,N) # max for 1. zero elements, 2. off diagonal elements, 3. the teleconnection center\n  V=genV(p=p,r=r,s=s,tele=tele)\n  S=V%*%t(V)+diag(rep(1,p))*sigma^2\n  M=(S==0)\n  \n  for(i in 1:p){\n    for(j in 1:p){\n      if(abs(i-j)<5){\n        M[i,j]=0\n      }\n    }\n  }\n  \n  for(k in 1:N){\n    \n    f=mvrnorm(n, mu = rep(0,p), Sigma = Ip)\n    E=mvrnorm(n, mu = rep(0,p), Sigma = Ip)\n    data = V%*%t(f)+sigma*t(E) #mvrnorm(n, mu = rep(0,p), Sigma = S)\n    Shat=cov(t(data))\n    if(0<type & type<=20){\n      Snorm=MnormM(Shat,h=2,type=type,RM=RM)\n      Shat=Snorm\n      #Shat=Shat*(Shat>2*(Snorm*log(p)/n))\n    }\n    if(type==21){\n      Shat=MnormMvar(t(data))\n    }\n    \n    resZ[k]=max(abs(Shat*M))\n    res691[k]=Shat[round(0.05*p)+1,round(0.9*p)+1] # Shat[6,91]\n    # for(i in 1:p){\n    #   Shat[i,i]=0\n    # }\n    # for(i in 1:(p-1)){\n    #   Shat[i,i+1]=Shat[i+1,i]=0\n    # }\n    # for(i in 1:(p-2)){\n    #   Shat[i,i+2]=Shat[i+2,i]=0\n    # }\n    # \n    # resOffDiag[k]=max(abs(Shat))\n  }\n  \n  #x=seq(min(resZ),max(resZ),length=100)\n  #y=dnorm(x,mean=mean(resZ), sd=sd(resZ))\n  #y2=dGumbel(x, mu = mean(resZ)-0.5772156649*sd(resZ)*sqrt(6)/pi, sigma = sd(resZ)*sqrt(6)/pi, log = FALSE) \n  \n  \n  plot(density(resZ),xlim=c(min(c(resZ,res691)),max(c(resZ,res691))),col=\"blue\",main=type)\n  lines(density(res691),lty=2,type=\"l\",col=\"red\")\n  abline(v=(mean(resZ)+mean(res691))/2,lty=3,col=\"orange\")\n  legend(\"topright\",c(\"random error max\",\"max off-diag signal\",\"(mean1+mean2)/2\"),col=c(\"blue\",\"red\",\"orange\"),lty=c(1,2,3),cex=0.5)\n  text(mean(resZ)+2*sd(resZ),range(density(resZ)$y)[2]/2,paste(\"mean:\",round(mean(resZ),4)),col=\"blue\")\n  text(mean(res691)+sd(res691),range(density(res691)$y)[2]/2,paste(\"mean:\",round(mean(res691),4)),col=\"red\")\n  \n  \n  #lines(x,y, type=\"l\", lwd=1,col=\"green\")\n  #lines(x,y2, type=\"l\", lwd=1,col=\"pink\")\n  #plotDen(resZ)\n}\n\n\n",
    "created" : 1493077691499.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3043684503",
    "id" : "F1E11423",
    "lastKnownWriteTime" : 1493736917,
    "last_content_update" : 1493736917050,
    "path" : "D:/works/clinet/utils_cov.R",
    "project_path" : "utils_cov.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}